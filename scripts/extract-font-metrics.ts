/**
 * OSS フォント (.ttf) からグリフ幅メトリクスを抽出するスクリプト。
 *
 * 使い方:
 *   1. scripts/fonts/ に対象フォントの .ttf を配置
 *   2. npx tsx scripts/extract-font-metrics.ts
 *   3. 出力された TypeScript コードを src/data/font-metrics.ts に貼り付け
 */
import opentype from "opentype.js";
import path from "node:path";
import { fileURLToPath } from "node:url";

const __dirname = path.dirname(fileURLToPath(import.meta.url));

interface ExtractedMetrics {
  unitsPerEm: number;
  ascender: number;
  descender: number;
  widths: Record<string, number>;
  defaultWidth: number;
  cjkWidth: number;
}

const FONTS = [
  { key: "Carlito", file: "Carlito-Regular.ttf" },
  { key: "LiberationSans", file: "LiberationSans-Regular.ttf" },
  { key: "LiberationSerif", file: "LiberationSerif-Regular.ttf" },
  { key: "NotoSansJP", file: "NotoSansJP-Regular.ttf" },
];

function extractMetrics(fontPath: string): ExtractedMetrics {
  const font = opentype.loadSync(fontPath);

  const widths: Record<string, number> = {};

  // U+0020 ~ U+00FF (Basic Latin + Latin-1 Supplement)
  for (let cp = 0x20; cp <= 0xff; cp++) {
    const char = String.fromCodePoint(cp);
    const glyph = font.charToGlyph(char);
    if (glyph && glyph.index !== 0) {
      widths[char] = glyph.advanceWidth;
    }
  }

  // CJK 代表文字
  const cjkChar = "\u4E00"; // "一"
  const cjkGlyph = font.charToGlyph(cjkChar);
  const cjkWidth = cjkGlyph && cjkGlyph.index !== 0 ? cjkGlyph.advanceWidth : font.unitsPerEm;

  // defaultWidth: 全 Latin-1 文字幅の平均
  const allWidths = Object.values(widths);
  const defaultWidth =
    allWidths.length > 0
      ? Math.round(allWidths.reduce((sum, w) => sum + w, 0) / allWidths.length)
      : font.unitsPerEm;

  return {
    unitsPerEm: font.unitsPerEm,
    ascender: font.ascender,
    descender: font.descender,
    widths,
    defaultWidth,
    cjkWidth,
  };
}

function escapeKey(char: string): string {
  const cp = char.codePointAt(0)!;
  if (char === '"') return '"\\""';
  if (char === "\\") return '"\\\\"';
  if (cp >= 0x20 && cp <= 0x7e) return `"${char}"`;
  return `"\\u${cp.toString(16).padStart(4, "0")}"`;
}

function formatMetrics(key: string, metrics: ExtractedMetrics): string {
  const widthEntries = Object.entries(metrics.widths)
    .map(([char, width]) => `    ${escapeKey(char)}: ${width}`)
    .join(",\n");

  return `  ${key}: {
    unitsPerEm: ${metrics.unitsPerEm},
    ascender: ${metrics.ascender},
    descender: ${metrics.descender},
    defaultWidth: ${metrics.defaultWidth},
    cjkWidth: ${metrics.cjkWidth},
    widths: {
${widthEntries},
    },
  }`;
}

// --- メイン処理 ---
const fontsDir = path.join(__dirname, "fonts");
const results: string[] = [];

for (const { key, file } of FONTS) {
  const fontPath = path.join(fontsDir, file);
  try {
    const metrics = extractMetrics(fontPath);
    results.push(formatMetrics(key, metrics));
    const charCount = Object.keys(metrics.widths).length;
    console.error(`✓ ${key}: ${charCount} chars extracted (unitsPerEm=${metrics.unitsPerEm})`);
  } catch (e) {
    console.error(`✗ ${key}: ${(e as Error).message}`);
  }
}

// TypeScript コードとして出力
console.log(`// Auto-generated by scripts/extract-font-metrics.ts
// Do not edit manually.

const metricsData = {
${results.join(",\n")},
} as const;

export default metricsData;
`);
